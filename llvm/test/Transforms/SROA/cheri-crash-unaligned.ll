; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; This test case previously triggered assertions in SROA ("Partitions must span some bytes!")
; RUN: opt -mtriple=riscv64-unknown-freebsd -S -passes=sroa < %s | FileCheck %s
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128"

%struct = type { i32, i32, i32, i32, ptr addrspace(200), ptr addrspace(200) }

define void @foo() {
; CHECK-LABEL: define {{[^@]+}}@foo() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF_SROA_0:%.*]] = alloca [12 x i8], align 4
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[B_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[TMPA_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[TMPB_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[BUF_SROA_0]])
; CHECK-NEXT:    [[TMPA_SROA_0_4_TMPA_4_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[TMPA_SROA_0]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[TMPA_SROA_0_4_TMPA_4_SROA_IDX]], ptr align 4 [[BUF_SROA_0]], i64 12, i1 false) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[TMPB_SROA_0_4_TMPB_4_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[TMPB_SROA_0]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[TMPB_SROA_0_4_TMPB_4_SROA_IDX]], ptr align 4 [[BUF_SROA_0]], i64 12, i1 false) #[[ATTR2]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[BUF_SROA_0]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[A_SROA_0]], ptr align 16 [[TMPA_SROA_0]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[B_SROA_0]], ptr align 16 [[TMPB_SROA_0]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [44 x i8], align 4
  %a = alloca %struct, align 16
  %b = alloca %struct, align 16
  %tmpa = alloca %struct, align 16
  %tmpb = alloca %struct, align 16
  %tmpa.4 = getelementptr inbounds i8, ptr %tmpa, i64 4
  %buf.cast = getelementptr inbounds [44 x i8], ptr %buf, i64 0, i64 0
  call void @llvm.lifetime.start.p0(i64 44, ptr %buf.cast)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmpa.4, ptr align 4 %buf.cast, i64 44, i1 false)
  %tmpb.4 = getelementptr inbounds i8, ptr %tmpb, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmpb.4, ptr align 4 %buf.cast, i64 44, i1 false)
  call void @llvm.lifetime.end.p0(i64 44, ptr %buf.cast)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %a, ptr align 16 %tmpa, i64 48, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b, ptr align 16 %tmpb, i64 48, i1 false)
  ret void
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)
