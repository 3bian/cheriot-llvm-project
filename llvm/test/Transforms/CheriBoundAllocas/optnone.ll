; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;; NB: We set -cheri-stack-bounds-single-intrinsic-threshold=1 so optnone
;; generates the same IR as its -cheri-stack-bounds-analysis equivalent.
; RUN: sed 's/@ATTRS@//g' %s | opt -mtriple=riscv64 -S \
; RUN:   -cheri-bound-allocas \
; RUN:   -cheri-stack-bounds-single-intrinsic-threshold=1 \
; RUN:   -cheri-stack-bounds-analysis=full \
; RUN:   | FileCheck %s --check-prefix=FULL-OPAQUE
; RUN: sed 's/@ATTRS@//g' %s | opt -mtriple=riscv64 -S \
; RUN:   -cheri-bound-allocas \
; RUN:   -cheri-stack-bounds-single-intrinsic-threshold=1 \
; RUN:   | FileCheck %s --check-prefixes=OPTNONE-OPAQUE
; RUN: sed 's/@ATTRS@//g' %s | opt -mtriple=riscv64 -S \
; RUN:   -cheri-bound-allocas \
; RUN:   -cheri-stack-bounds-single-intrinsic-threshold=1 \
; RUN:   -cheri-stack-bounds-analysis=simple \
; RUN:   | FileCheck %s --check-prefix=SIMPLE-OPAQUE
; RUN: sed 's/@ATTRS@//g' %s | opt -mtriple=riscv64 -S \
; RUN:   -cheri-bound-allocas \
; RUN:   -cheri-stack-bounds-single-intrinsic-threshold=1 \
; RUN:   -cheri-stack-bounds-analysis=none \
; RUN:   | FileCheck %s --check-prefix=NONE-OPAQUE

target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"

define i32 @load_store_direct(i32 %a) @ATTRS@ {
; FULL-OPAQUE-LABEL: @load_store_direct(
; FULL-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; FULL-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP1]], align 4
; FULL-OPAQUE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[TMP1]], align 4
; FULL-OPAQUE-NEXT:    ret i32 [[TMP2]]
;
; OPTNONE-OPAQUE-LABEL: @load_store_direct(
; OPTNONE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; OPTNONE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP1]], align 4
; OPTNONE-OPAQUE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[TMP1]], align 4
; OPTNONE-OPAQUE-NEXT:    ret i32 [[TMP2]]
;
; SIMPLE-OPAQUE-LABEL: @load_store_direct(
; SIMPLE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; SIMPLE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP1]], align 4
; SIMPLE-OPAQUE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[TMP1]], align 4
; SIMPLE-OPAQUE-NEXT:    ret i32 [[TMP2]]
;
; NONE-OPAQUE-LABEL: @load_store_direct(
; NONE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; NONE-OPAQUE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[TMP1]], i64 4)
; NONE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP2]], align 4
; NONE-OPAQUE-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(200) [[TMP2]], align 4
; NONE-OPAQUE-NEXT:    ret i32 [[TMP3]]
;
  %1 = alloca i32, align 4, addrspace(200)
  store i32 %a, ptr addrspace(200) %1, align 4
  %2 = load i32, ptr addrspace(200) %1, align 4
  ret i32 %2
}

define i32 @load_store_indirect(i32 %a) @ATTRS@ {
; FULL-OPAQUE-LABEL: @load_store_indirect(
; FULL-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; FULL-OPAQUE-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP1]], i64 1
; FULL-OPAQUE-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP2]], i64 -1
; FULL-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP3]], align 4
; FULL-OPAQUE-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(200) [[TMP3]], align 4
; FULL-OPAQUE-NEXT:    ret i32 [[TMP4]]
;
; OPTNONE-OPAQUE-LABEL: @load_store_indirect(
; OPTNONE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; OPTNONE-OPAQUE-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP1]], i64 1
; OPTNONE-OPAQUE-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP2]], i64 -1
; OPTNONE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP3]], align 4
; OPTNONE-OPAQUE-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(200) [[TMP3]], align 4
; OPTNONE-OPAQUE-NEXT:    ret i32 [[TMP4]]
;
; SIMPLE-OPAQUE-LABEL: @load_store_indirect(
; SIMPLE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; SIMPLE-OPAQUE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[TMP1]], i64 4)
; SIMPLE-OPAQUE-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP2]], i64 1
; SIMPLE-OPAQUE-NEXT:    [[TMP4:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP3]], i64 -1
; SIMPLE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP4]], align 4
; SIMPLE-OPAQUE-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(200) [[TMP4]], align 4
; SIMPLE-OPAQUE-NEXT:    ret i32 [[TMP5]]
;
; NONE-OPAQUE-LABEL: @load_store_indirect(
; NONE-OPAQUE-NEXT:    [[TMP1:%.*]] = alloca i32, align 4, addrspace(200)
; NONE-OPAQUE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[TMP1]], i64 4)
; NONE-OPAQUE-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP2]], i64 1
; NONE-OPAQUE-NEXT:    [[TMP4:%.*]] = getelementptr i32, ptr addrspace(200) [[TMP3]], i64 -1
; NONE-OPAQUE-NEXT:    store i32 [[A:%.*]], ptr addrspace(200) [[TMP4]], align 4
; NONE-OPAQUE-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(200) [[TMP4]], align 4
; NONE-OPAQUE-NEXT:    ret i32 [[TMP5]]
;
  %1 = alloca i32, align 4, addrspace(200)
  %2 = getelementptr i32, ptr addrspace(200) %1, i64 1
  %3 = getelementptr i32, ptr addrspace(200) %2, i64 -1
  store i32 %a, ptr addrspace(200) %3, align 4
  %4 = load i32, ptr addrspace(200) %3, align 4
  ret i32 %4
}
