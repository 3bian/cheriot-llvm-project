; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_purecap_llc -O0 %s -o - | FileCheck %s

; Function Attrs: nounwind
define void @zero(ptr addrspace(200) nocapture %out) local_unnamed_addr nounwind {
; CHECK-LABEL: zero:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, 10794
; CHECK-NEXT:    ori $1, $1, 10794
; CHECK-NEXT:    csw $1, $zero, 16($c3)
; CHECK-NEXT:    lui $1, 5397
; CHECK-NEXT:    daddiu $1, $1, 5397
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    daddiu $1, $1, 5397
; CHECK-NEXT:    dsll $1, $1, 17
; CHECK-NEXT:    daddiu $1, $1, 10794
; CHECK-NEXT:    csd $1, $zero, 8($c3)
; CHECK-NEXT:    csd $1, $zero, 0($c3)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  call void @llvm.memset.p200.i64(ptr addrspace(200) align 16 %out, i8 42, i64 20, i1 false)
; Check that the non-zero memset is expanded to stores.
; Not a very comprehensive test, but the materialisation of integers is complex
; here and the way that the MIPS back end currently does it is a bit insane.  If
; we really cared about this case, we'd emit lui, ori, dsll, or, and then use
; that for both csw and csd.
  ret void
}

declare void @llvm.memset.p200.i64(ptr addrspace(200) nocapture writeonly, i8, i64, i1 immarg)
