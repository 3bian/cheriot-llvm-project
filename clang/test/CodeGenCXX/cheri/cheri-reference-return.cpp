// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_cc1 -no-opaque-pointers -emit-llvm -o - %s | FileCheck %s

// CHECK-LABEL: define {{[^@]+}}@_Z2t1U12__capabilityPi
// CHECK-SAME: (i32 addrspace(200)* noundef [[TAB:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TAB_ADDR:%.*]] = alloca i32 addrspace(200)*, align 16
// CHECK-NEXT:    store i32 addrspace(200)* [[TAB]], i32 addrspace(200)** [[TAB_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)** [[TAB_ADDR]], align 16
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32 addrspace(200)* [[TMP0]], i64 2
// CHECK-NEXT:    [[ARRAYIDX_ASCAST:%.*]] = addrspacecast i32 addrspace(200)* [[ARRAYIDX]] to i32*
// CHECK-NEXT:    ret i32* [[ARRAYIDX_ASCAST]]
//
int &t1(int *__capability tab) {
  return *(__cheri_fromcap int *)&tab[2];
}

// CHECK-LABEL: define {{[^@]+}}@_Z2t2U12__capabilityPi
// CHECK-SAME: (i32 addrspace(200)* noundef [[T:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[T_ADDR:%.*]] = alloca i32 addrspace(200)*, align 16
// CHECK-NEXT:    store i32 addrspace(200)* [[T]], i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i32 addrspace(200)* [[TMP0]] to i32*
// CHECK-NEXT:    ret i32* [[TMP1]]
//
int &t2(int *__capability t) {
  return *(__cheri_fromcap int *)t;
}

// CHECK-LABEL: define {{[^@]+}}@_Z2t3U12__capabilityPi
// CHECK-SAME: (i32 addrspace(200)* noundef [[T:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[T_ADDR:%.*]] = alloca i32 addrspace(200)*, align 16
// CHECK-NEXT:    store i32 addrspace(200)* [[T]], i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i32 addrspace(200)* [[TMP0]] to i32*
// CHECK-NEXT:    ret i32* [[TMP1]]
//
const int &t3(int *__capability t) {
  return *(__cheri_fromcap int *)t;
}

// CHECK-LABEL: define {{[^@]+}}@_Z2t4U12__capabilityPi
// CHECK-SAME: (i32 addrspace(200)* noundef [[T:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[T_ADDR:%.*]] = alloca i32 addrspace(200)*, align 16
// CHECK-NEXT:    store i32 addrspace(200)* [[T]], i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)** [[T_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i32 addrspace(200)* [[TMP0]] to i32*
// CHECK-NEXT:    ret i32* [[TMP1]]
//
const int &t4(int *__capability t) {
  return *(__cheri_fromcap int *)(t);
}
