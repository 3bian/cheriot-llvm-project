// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -no-opaque-pointers -emit-llvm -o - %s | FileCheck %s
// Check that rvalue references to capabilities use the correct IR type
__intcap_t g();

// CHECK-LABEL: @_Z1fv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A2:%.*]] = alloca i8 addrspace(200)**, align 8
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca i8 addrspace(200)*, align 16
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i8 addrspace(200)* @_Z1gv()
// CHECK-NEXT:    store i8 addrspace(200)* [[CALL]], i8 addrspace(200)** [[REF_TMP]], align 16
// CHECK-NEXT:    store i8 addrspace(200)** [[REF_TMP]], i8 addrspace(200)*** [[A2]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)**, i8 addrspace(200)*** [[A2]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[TMP0]], align 16
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 addrspace(200)* [[TMP1]], null
// CHECK-NEXT:    ret i1 [[CMP]]
//
bool f() {
  __intcap_t&& a2 = g();
  return a2 == 0;
}
