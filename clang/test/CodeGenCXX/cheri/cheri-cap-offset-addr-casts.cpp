// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// Test IR generation for __cheri_{offset, addr} when used with C++ features
// RUN: %cheri_cc1 -std=c++11 -fsyntax-only %s -verify=expected,hybrid
// RUN: %cheri_purecap_cc1 -std=c++11 -fsyntax-only %s -verify
// RUN: %cheri_purecap_cc1 -std=c++11 -x c++ -DCODEGEN -O1 -emit-llvm -o - %s | FileCheck %s

class A {};
// CHECK-LABEL: define {{[^@]+}}@_Z1fv
// CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void f() { };

#ifndef CODEGEN
// Test object references
void objrefs_bad(A& a) {
  long x1 = (__cheri_offset long)a; // expected-error-re{{invalid source type 'A &{{( __capability)?}}' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)a;   // expected-error-re{{invalid source type 'A &{{( __capability)?}}' for __cheri_addr: source must be a capability}}
}

// Test function references
void funcref_bad(void (&f)(void)) {
  long x1 = (__cheri_offset long)f; // hybrid-error{{invalid source type 'void (*)()' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)f;
}
#endif

// Test object references
// CHECK-LABEL: define {{[^@]+}}@_Z14objrefs_addrofR1A
// CHECK-SAME: (ptr addrspace(200) noundef nonnull align 1 dereferenceable(1) [[A:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[A]])
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) nonnull [[A]])
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP0]]
// CHECK-NEXT:    ret i64 [[ADD]]
//
long objrefs_addrof(A& a) {
  long x1 = (__cheri_offset long)&a; // hybrid-error{{invalid source type 'A *' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)&a;
  return x1 + x2;
}

// Test function references
// CHECK-LABEL: define {{[^@]+}}@_Z14funcref_addrofRFvvE
// CHECK-SAME: (ptr addrspace(200) noundef nonnull [[F:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[F]])
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) nonnull [[F]])
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP0]]
// CHECK-NEXT:    ret i64 [[ADD]]
//
long funcref_addrof(void (&f)(void)) {
  long x1 = (__cheri_offset long)&f; // hybrid-error{{invalid source type 'void (*)()' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)&f;
  return x1 + x2;
}
