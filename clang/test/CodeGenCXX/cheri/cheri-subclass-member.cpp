// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_cc1 -ast-dump -o /dev/null %s 2>&1 | FileCheck %s -check-prefix AST
// RUN: %cheri_cc1 -no-opaque-pointers -emit-llvm -o - %s | FileCheck %s

// Check that a UncheckedDerivedToBase cast does not remove the __capability qualifier

// AST:      `-FunctionDecl {{.+}} func 'const long & __capability ()'
// AST-NEXT:  `-CompoundStmt
// AST-NEXT:   `-ReturnStmt
// AST-NEXT:    `-MemberExpr {{.+}} 'const long' lvalue ->size
// AST-NEXT:     `-ImplicitCastExpr {{.+}} 's1 * __capability' <UncheckedDerivedToBase (s1)>
// AST-NEXT:      `-ImplicitCastExpr {{.+}} 'const s2 * __capability' <LValueToRValue>
// AST-NEXT:       `-DeclRefExpr {{.+}} 'const s2 * __capability' lvalue Var {{.+}} 'c_s2' 'const s2 * __capability'

struct s1 {
  long size;
};

struct s2 : public s1 {
};

const s2 *__capability c_s2;

// CHECK-LABEL: define {{[^@]+}}@_Z4funcv
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load [[STRUCT_S2:%.*]] addrspace(200)*, [[STRUCT_S2]] addrspace(200)** @c_s2, align 16
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_S2]] addrspace(200)* [[TMP0]] to [[STRUCT_S1:%.*]] addrspace(200)*
// CHECK-NEXT:    [[SIZE:%.*]] = getelementptr inbounds [[STRUCT_S1]], [[STRUCT_S1]] addrspace(200)* [[TMP1]], i32 0, i32 0
// CHECK-NEXT:    ret i64 addrspace(200)* [[SIZE]]
//
const long &__capability func() {
  return c_s2->size;
}
