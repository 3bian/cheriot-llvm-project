// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN:  %cheri_purecap_cc1 -no-opaque-pointers -emit-llvm -std=c++11 -o - %s | FileCheck %s
struct foo {
  foo();
};

// UTC_ARGS: --disable
// CHECK: @_ZZ1fvE1x = internal addrspace(200) global %struct.foo zeroinitializer, align 1
// CHECK: @_ZGVZ1fvE1x = internal addrspace(200) global i64 0, align 8
// UTC_ARGS: --enable

// CHECK-LABEL: define {{[^@]+}}@_Z1fv
// CHECK-SAME: () addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load atomic i8, i8 addrspace(200)* bitcast (i64 addrspace(200)* @_ZGVZ1fvE1x to i8 addrspace(200)*) acquire, align 8
// CHECK-NEXT:    [[GUARD_UNINITIALIZED:%.*]] = icmp eq i8 [[TMP0]], 0
// CHECK-NEXT:    br i1 [[GUARD_UNINITIALIZED]], label [[INIT_CHECK:%.*]], label [[INIT_END:%.*]], !prof [[PROF2:![0-9]+]]
// CHECK:       init.check:
// CHECK-NEXT:    [[TMP1:%.*]] = call i32 @__cxa_guard_acquire(i64 addrspace(200)* @_ZGVZ1fvE1x) #[[ATTR1:[0-9]+]]
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP1]], 0
// CHECK-NEXT:    br i1 [[TOBOOL]], label [[INIT:%.*]], label [[INIT_END]]
// CHECK:       init:
// CHECK-NEXT:    call void @_ZN3fooC1Ev([[STRUCT_FOO:%.*]] addrspace(200)* noundef nonnull align 1 dereferenceable(1) @_ZZ1fvE1x)
// CHECK-NEXT:    call void @__cxa_guard_release(i64 addrspace(200)* @_ZGVZ1fvE1x) #[[ATTR1]]
// CHECK-NEXT:    br label [[INIT_END]]
// CHECK:       init.end:
// CHECK-NEXT:    ret [[STRUCT_FOO]] addrspace(200)* @_ZZ1fvE1x
//
foo *f() {
  static foo x;
  return &x;
}

// UTC_ARGS: --disable
// CHECK: declare i32 @__cxa_guard_acquire(i64 addrspace(200)*)
// CHECK: declare void @__cxa_guard_release(i64 addrspace(200)*)
