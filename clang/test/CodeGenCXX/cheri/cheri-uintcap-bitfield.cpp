// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_purecap_cc1 %s -std=c++14 -emit-llvm -o - -verify
// RUN: %cheri_purecap_cc1 %s -std=c++14 -DCODEGEN -emit-llvm -o - | FileCheck %s
/// Bitfields with underlying type __uintcap_t used to cause assertions. Found while compiling qdatetime.cpp for purecap ABI
/// TODO: we should be able to generate code for this (truncating to 64 bits), but for
/// now emitting an error is better than crashing since this is a rather niche use case.

typedef __intcap_t qintptr;
typedef __uintcap_t quintptr;

#ifndef CODEGEN
struct AnonBitfield {
  quintptr : 8; // expected-error{{anonymous bit-field has capability type 'quintptr' (aka 'unsigned __intcap'); this is not supported yet}}
};

struct ShortDataIntptr {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  quintptr status : 8;
#endif
  qintptr msecs : sizeof(void *) * 8L - 8;
  // expected-error@-1{{bit-field 'msecs' has capability type 'qintptr' (aka '__intcap'); this is not supported yet}}
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  quintptr status : 8; // expected-error{{bit-field 'status' has capability type 'quintptr' (aka 'unsigned __intcap'); this is not supported yet}}
#endif
};

void setMsecsIntptr(ShortDataIntptr *data, long f) {
  data->msecs = f;
  data->msecs = qintptr(f);
  data->status = 24;
}
#endif

struct ShortDataLong {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  unsigned long status : 8;
#endif
  unsigned long msecs : sizeof(void *) * 8L - 8;
  // expected-warning@-1{{width of bit-field 'msecs' (120 bits) exceeds the width of its type; value will be truncated to 64 bits}}
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  unsigned long status : 8;
#endif
};

// CHECK-LABEL: define {{[^@]+}}@setMsecsLong
// CHECK-SAME: (ptr addrspace(200) noundef [[DATA:%.*]], i64 noundef signext [[F:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    [[F_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[DATA]], ptr addrspace(200) [[DATA_ADDR]], align 16
// CHECK-NEXT:    store i64 [[F]], ptr addrspace(200) [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr addrspace(200) [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = zext i64 [[TMP0]] to i128
// CHECK-NEXT:    [[BF_LOAD:%.*]] = load i128, ptr addrspace(200) [[TMP1]], align 8
// CHECK-NEXT:    [[BF_VALUE:%.*]] = and i128 [[TMP2]], 1329227995784915872903807060280344575
// CHECK-NEXT:    [[BF_SHL:%.*]] = shl i128 [[BF_VALUE]], 8
// CHECK-NEXT:    [[BF_CLEAR:%.*]] = and i128 [[BF_LOAD]], 255
// CHECK-NEXT:    [[BF_SET:%.*]] = or i128 [[BF_CLEAR]], [[BF_SHL]]
// CHECK-NEXT:    store i128 [[BF_SET]], ptr addrspace(200) [[TMP1]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr addrspace(200) [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[TMP3]]
// CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[TMP7:%.*]] = zext i64 [[TMP5]] to i128
// CHECK-NEXT:    [[BF_LOAD1:%.*]] = load i128, ptr addrspace(200) [[TMP6]], align 8
// CHECK-NEXT:    [[BF_VALUE2:%.*]] = and i128 [[TMP7]], 1329227995784915872903807060280344575
// CHECK-NEXT:    [[BF_SHL3:%.*]] = shl i128 [[BF_VALUE2]], 8
// CHECK-NEXT:    [[BF_CLEAR4:%.*]] = and i128 [[BF_LOAD1]], 255
// CHECK-NEXT:    [[BF_SET5:%.*]] = or i128 [[BF_CLEAR4]], [[BF_SHL3]]
// CHECK-NEXT:    store i128 [[BF_SET5]], ptr addrspace(200) [[TMP6]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[BF_LOAD6:%.*]] = load i128, ptr addrspace(200) [[TMP8]], align 8
// CHECK-NEXT:    [[BF_CLEAR7:%.*]] = and i128 [[BF_LOAD6]], -256
// CHECK-NEXT:    [[BF_SET8:%.*]] = or i128 [[BF_CLEAR7]], 24
// CHECK-NEXT:    store i128 [[BF_SET8]], ptr addrspace(200) [[TMP8]], align 8
// CHECK-NEXT:    ret void
//
extern "C" void setMsecsLong(ShortDataLong *data, long f) {
  data->msecs = f;
  data->msecs = qintptr(f);
  data->status = 24;
}
