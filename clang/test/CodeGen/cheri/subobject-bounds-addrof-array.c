// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// Check that we can set bounds on addrof expressions
// REQUIRES: asserts
// RUN: rm -f %t-s.dbg %t-a.dbg %t-v.dbg

// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O0 -std=c11 -emit-llvm %s -o - \
// RUN:   -mllvm -debug-only=cheri-bounds -mllvm -stats -Wno-array-bounds \
// RUN:   -Rcheri-subobject-bounds -verify=subobject-safe,common,aggressive-or-less 2>%t-s.dbg \
// RUN:   | FileCheck %s --check-prefixes AGGRESSIVE-OR-LESS,SUBOBJECT-SAFE
// RUN: FileCheck %s -input-file %t-s.dbg -check-prefixes DBG,DBG-SUBOBJECT-SAFE

// RUN: %cheri_purecap_cc1 -cheri-bounds=aggressive -O0 -std=c11 -emit-llvm %s -o - \
// RUN:   -mllvm -debug-only=cheri-bounds -mllvm -stats -Wno-array-bounds \
// RUN:   -Rcheri-subobject-bounds -verify=aggressive,common,aggressive-or-less 2>%t-a.dbg \
// RUN:   | FileCheck %s --check-prefixes AGGRESSIVE-OR-LESS,AGGRESSIVE
// RUN: FileCheck %s -input-file %t-a.dbg -check-prefixes DBG,DBG-AGGRESSIVE

// RUN: %cheri_purecap_cc1 -cheri-bounds=very-aggressive -O0 -std=c11 -emit-llvm %s -o - \
// RUN:   -mllvm -debug-only=cheri-bounds -mllvm -stats -Wno-array-bounds \
// RUN:   -Rcheri-subobject-bounds -verify=very-aggressive,common 2>%t-v.dbg \
// RUN:   | FileCheck %s --check-prefixes VERY-AGGRESSIVE
// RUN: FileCheck %s -input-file %t-v.dbg -check-prefixes DBG,DBG-VERY-AGGRESSIVE

struct WithTrailingArray {
  int len;
  char buf[];
};

struct WithLen1ArrayAtEnd {
  int len;
  char buf[1];
};

struct WithLen0ArrayAtEnd {
  int len;
  char buf[0];
};

struct WithLen1ArrayNotAtEnd {
  int len;
  char buf[1];
  int something_else;
};

struct Foo {
  int value;
};

struct WithLen2Array {
  int len;
  struct Foo values[3];
};

void do_stuff_untyped(void *);

// AGGRESSIVE-OR-LESS-LABEL: @test_len2_array_1(
// AGGRESSIVE-OR-LESS-NEXT:  entry:
// AGGRESSIVE-OR-LESS-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// AGGRESSIVE-OR-LESS-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP0]], i32 0, i32 1
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// AGGRESSIVE-OR-LESS-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// AGGRESSIVE-OR-LESS-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test_len2_array_1(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP0]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test_len2_array_1(struct WithLen2Array *s) {
  // In safe mode there should not be any bounds here:
  do_stuff_untyped(&s->values);
  // common-remark@-1 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo[3]') to 12 bytes}}
  // DBG: Found constant size array type -> setting bounds for 'struct Foo[3]' address to 12
}

// SUBOBJECT-SAFE-LABEL: @test_len2_array_2(
// SUBOBJECT-SAFE-NEXT:  entry:
// SUBOBJECT-SAFE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// SUBOBJECT-SAFE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP0]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP1]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP2]], i64 0, i64 0
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX]])
// SUBOBJECT-SAFE-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES1:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP3]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES1]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP4]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP5]], i64 0, i64 1
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX2]])
// SUBOBJECT-SAFE-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES3:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP6]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP7:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES3]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP8:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP7]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP8]], i64 0, i64 2
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX4]])
// SUBOBJECT-SAFE-NEXT:    [[TMP9:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES5:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP9]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES5]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP11:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP10]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP11]], i64 0, i64 3
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX6]])
// SUBOBJECT-SAFE-NEXT:    [[TMP12:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES7:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP12]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP13:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES7]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP14:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP13]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP14]], i64 0, i64 4
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX8]])
// SUBOBJECT-SAFE-NEXT:    ret void
//
// AGGRESSIVE-LABEL: @test_len2_array_2(
// AGGRESSIVE-NEXT:  entry:
// AGGRESSIVE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// AGGRESSIVE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP0]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// AGGRESSIVE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP1]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP2]], i64 0, i64 0
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX]])
// AGGRESSIVE-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES1:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP3]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES1]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP4]], i64 0, i64 1
// AGGRESSIVE-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX2]], i64 4)
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP5]])
// AGGRESSIVE-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES3:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP6]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP7:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES3]], i64 12)
// AGGRESSIVE-NEXT:    [[TMP8:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP7]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP8]], i64 0, i64 2
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX4]])
// AGGRESSIVE-NEXT:    [[TMP9:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES5:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP9]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES5]], i64 12)
// AGGRESSIVE-NEXT:    [[TMP11:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP10]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP11]], i64 0, i64 3
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX6]])
// AGGRESSIVE-NEXT:    [[TMP12:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES7:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP12]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP13:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES7]], i64 12)
// AGGRESSIVE-NEXT:    [[TMP14:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP13]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP14]], i64 0, i64 4
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX8]])
// AGGRESSIVE-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test_len2_array_2(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP0]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP1]], i64 0, i64 0
// VERY-AGGRESSIVE-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP2]])
// VERY-AGGRESSIVE-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES1:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP3]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES1]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP4]], i64 0, i64 1
// VERY-AGGRESSIVE-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX2]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP5]])
// VERY-AGGRESSIVE-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES3:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP6]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP7:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES3]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP7]], i64 0, i64 2
// VERY-AGGRESSIVE-NEXT:    [[TMP8:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX4]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP8]])
// VERY-AGGRESSIVE-NEXT:    [[TMP9:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES5:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP9]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES5]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP10]], i64 0, i64 3
// VERY-AGGRESSIVE-NEXT:    [[TMP11:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX6]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP11]])
// VERY-AGGRESSIVE-NEXT:    [[TMP12:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES7:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY]], ptr addrspace(200) [[TMP12]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP13:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES7]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP13]], i64 0, i64 4
// VERY-AGGRESSIVE-NEXT:    [[TMP14:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX8]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP14]])
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test_len2_array_2(struct WithLen2Array *s) {
  // should only set bounds in very agressive mode here
  // aggressive mode only sets bounds for not-start and not-end of array
  // NOTE: very aggressive even sets bounds on &array[0]/&array[last_index]?

  do_stuff_untyped(&s->values[0]); // &array[0] probably means the full array
  // aggressive-or-less-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[0]}}
  // aggressive-or-less-remark@-2 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
  // very-aggressive-remark@-3 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // common-remark@-4 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}


  // DBG-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[0] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[0] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
  // DBG-VERY-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4

  do_stuff_untyped(&s->values[1]); // probably fine to set bounds here in aggressive (but not in safe mode)
  // subobject-safe-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[<CONSTANT>]}}
  // subobject-safe-remark@-2 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
  // aggressive-remark@-3 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // very-aggressive-remark@-4 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // common-remark@-5 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}


  // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[<CONSTANT>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
  // DBG-VERY-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4
  // DBG-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> const array index is not end and bounds==aggressive -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4

  do_stuff_untyped(&s->values[2]); // should only set bounds in very-agressive mode here
  // subobject-safe-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[<CONSTANT>]}}
  // aggressive-remark@-2 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on bounds on &array[<last index>]}}
  // aggressive-or-less-remark@-3 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
  // very-aggressive-remark@-4 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // common-remark@-5 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}


  // DBG-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> bounds on &array[<last index>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[<CONSTANT>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
  // DBG-VERY-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4

  do_stuff_untyped(&s->values[3]); // should only set bounds in very-agressive mode here
  // subobject-safe-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[<CONSTANT>]}}
  // aggressive-remark@-2 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on bounds on &array[<last index>]}}
  // aggressive-or-less-remark@-3 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
  // very-aggressive-remark@-4 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // common-remark@-5 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}


  // DBG-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> bounds on &array[<last index>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[<CONSTANT>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
  // DBG-VERY-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4

  do_stuff_untyped(&s->values[4]); // should only set bounds in very-agressive mode here
  // subobject-safe-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[<CONSTANT>]}}
  // aggressive-remark@-2 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on bounds on &array[<last index>]}}
  // aggressive-or-less-remark@-3 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
  // very-aggressive-remark@-4 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
  // common-remark@-5 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}

  // DBG-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> bounds on &array[<last index>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> index is a constant -> &array[<CONSTANT>] -> using container size -> setting bounds for 'struct Foo' address to 12
  // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
  // DBG-VERY-AGGRESSIVE-NEXT: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4

}

// SUBOBJECT-SAFE-LABEL: @test_len2_array_3(
// SUBOBJECT-SAFE-NEXT:  entry:
// SUBOBJECT-SAFE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// SUBOBJECT-SAFE-NEXT:    [[I:%.*]] = alloca i32, align 4, addrspace(200)
// SUBOBJECT-SAFE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    store i32 0, ptr addrspace(200) [[I]], align 4
// SUBOBJECT-SAFE-NEXT:    br label [[FOR_COND:%.*]]
// SUBOBJECT-SAFE:       for.cond:
// SUBOBJECT-SAFE-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// SUBOBJECT-SAFE-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 3
// SUBOBJECT-SAFE-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// SUBOBJECT-SAFE:       for.body:
// SUBOBJECT-SAFE-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// SUBOBJECT-SAFE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP1]], i32 0, i32 1
// SUBOBJECT-SAFE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// SUBOBJECT-SAFE-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP2]] to i64
// SUBOBJECT-SAFE-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[TMP3]], i64 12)
// SUBOBJECT-SAFE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP4]], i64 0, i64 [[IDXPROM]]
// SUBOBJECT-SAFE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX]])
// SUBOBJECT-SAFE-NEXT:    br label [[FOR_INC:%.*]]
// SUBOBJECT-SAFE:       for.inc:
// SUBOBJECT-SAFE-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// SUBOBJECT-SAFE-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP5]], 1
// SUBOBJECT-SAFE-NEXT:    store i32 [[INC]], ptr addrspace(200) [[I]], align 4
// SUBOBJECT-SAFE-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// SUBOBJECT-SAFE:       for.end:
// SUBOBJECT-SAFE-NEXT:    ret void
//
// AGGRESSIVE-LABEL: @test_len2_array_3(
// AGGRESSIVE-NEXT:  entry:
// AGGRESSIVE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// AGGRESSIVE-NEXT:    [[I:%.*]] = alloca i32, align 4, addrspace(200)
// AGGRESSIVE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    store i32 0, ptr addrspace(200) [[I]], align 4
// AGGRESSIVE-NEXT:    br label [[FOR_COND:%.*]]
// AGGRESSIVE:       for.cond:
// AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// AGGRESSIVE-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 3
// AGGRESSIVE-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// AGGRESSIVE:       for.body:
// AGGRESSIVE-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// AGGRESSIVE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP1]], i32 0, i32 1
// AGGRESSIVE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// AGGRESSIVE-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP2]] to i64
// AGGRESSIVE-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP3]], i64 0, i64 [[IDXPROM]]
// AGGRESSIVE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP4]])
// AGGRESSIVE-NEXT:    br label [[FOR_INC:%.*]]
// AGGRESSIVE:       for.inc:
// AGGRESSIVE-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// AGGRESSIVE-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP5]], 1
// AGGRESSIVE-NEXT:    store i32 [[INC]], ptr addrspace(200) [[I]], align 4
// AGGRESSIVE-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// AGGRESSIVE:       for.end:
// AGGRESSIVE-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test_len2_array_3(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[S_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    [[I:%.*]] = alloca i32, align 4, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    store ptr addrspace(200) [[S:%.*]], ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    store i32 0, ptr addrspace(200) [[I]], align 4
// VERY-AGGRESSIVE-NEXT:    br label [[FOR_COND:%.*]]
// VERY-AGGRESSIVE:       for.cond:
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// VERY-AGGRESSIVE-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 3
// VERY-AGGRESSIVE-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// VERY-AGGRESSIVE:       for.body:
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[VALUES:%.*]] = getelementptr inbounds [[STRUCT_WITHLEN2ARRAY:%.*]], ptr addrspace(200) [[TMP1]], i32 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// VERY-AGGRESSIVE-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP2]] to i64
// VERY-AGGRESSIVE-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[VALUES]], i64 12)
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x %struct.Foo], ptr addrspace(200) [[TMP3]], i64 0, i64 [[IDXPROM]]
// VERY-AGGRESSIVE-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP4]])
// VERY-AGGRESSIVE-NEXT:    br label [[FOR_INC:%.*]]
// VERY-AGGRESSIVE:       for.inc:
// VERY-AGGRESSIVE-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(200) [[I]], align 4
// VERY-AGGRESSIVE-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP5]], 1
// VERY-AGGRESSIVE-NEXT:    store i32 [[INC]], ptr addrspace(200) [[I]], align 4
// VERY-AGGRESSIVE-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// VERY-AGGRESSIVE:       for.end:
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test_len2_array_3(struct WithLen2Array *s) {
  for (int i = 0; i < 3; i++) {
    // probably okay to set bounds here since this generally means only the given object
    // TODO: would be nice to set bounds here even in safe mode but it seems like this breaks lots of C code
    do_stuff_untyped(&s->values[i]); // should set bounds here since this will usually be a single object
    // subobject-safe-remark@-1 {{using size of containing type 'struct Foo[3]' instead of object type 'struct Foo' for subobject bounds on &array[n]}}
    // subobject-safe-remark@-2 {{setting sub-object bounds for pointer to 'struct Foo' to 12 bytes}}
    // aggressive-remark@-3 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
    // very-aggressive-remark@-4 {{setting sub-object bounds for field 'values' (pointer to 'struct Foo') to 4 bytes}}
    // common-remark@-5 {{setting sub-object bounds for field 'values' (array subscript on 'struct Foo[3]') to 12 bytes}}

    // DBG-SUBOBJECT-SAFE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> Index is not a constant (probably in a per-element loop) -> &array[n] -> using container size -> setting bounds for 'struct Foo' address to 12
    // DBG-NEXT: subscript 'struct Foo[3]' subobj bounds check: got MemberExpr -> subscript on constant size array -> setting bounds for 'struct Foo[3]' subscript to 12
    // DBG-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> Index is not a constant (probably in a per-element loop) -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4
    // DBG-VERY-AGGRESSIVE-NEXT: subobj bounds check: got MemberExpr ->  Found array subscript -> Index is not a constant (probably in a per-element loop) -> Found record type 'struct Foo' -> compiling C and no flexible array -> setting bounds for 'struct Foo' address to 4
  }
}

// AGGRESSIVE-OR-LESS-LABEL: @test2(
// AGGRESSIVE-OR-LESS-NEXT:  entry:
// AGGRESSIVE-OR-LESS-NEXT:    [[ARRAY_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// AGGRESSIVE-OR-LESS-NEXT:    store ptr addrspace(200) [[ARRAY:%.*]], ptr addrspace(200) [[ARRAY_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr addrspace(200) [[TMP0]], i64 0
// AGGRESSIVE-OR-LESS-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX]])
// AGGRESSIVE-OR-LESS-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test2(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[ARRAY_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    store ptr addrspace(200) [[ARRAY:%.*]], ptr addrspace(200) [[ARRAY_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr addrspace(200) [[TMP0]], i64 0
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test2(int *array) {
  // Should use the full array here except in very-aggressive mode.
  // However the size of the array is not known so we should not be setting any bounds!
  do_stuff_untyped(&array[0]);
  // aggressive-or-less-remark@-1{{not setting bounds for pointer to 'int' (should set bounds on full array but size is not known)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for pointer to 'int' to 4 bytes}}
  // common-remark@-3{{not setting bounds for array subscript on 'int *' (array subscript on non-array type)}}

  // DBG-SUBOBJECT-SAFE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> should set bounds on full array but size is not known -> not setting bounds
  // DBG-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> should set bounds on full array but size is not known -> not setting bounds
  // DBG-NEXT: subscript 'int * __capability' subobj bounds check: array subscript on non-array type -> not setting bounds
  // DBG-VERY-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found scalar type -> setting bounds for 'int' address to 4
}

// AGGRESSIVE-OR-LESS-LABEL: @test_unsized_array(
// AGGRESSIVE-OR-LESS-NEXT:  entry:
// AGGRESSIVE-OR-LESS-NEXT:    [[ARRAY_PARAM_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// AGGRESSIVE-OR-LESS-NEXT:    store ptr addrspace(200) [[ARRAY_PARAM:%.*]], ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr addrspace(200) [[TMP0]], i64 0
// AGGRESSIVE-OR-LESS-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[ARRAYIDX]])
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// AGGRESSIVE-OR-LESS-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// AGGRESSIVE-OR-LESS-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test_unsized_array(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[ARRAY_PARAM_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// VERY-AGGRESSIVE-NEXT:    store ptr addrspace(200) [[ARRAY_PARAM:%.*]], ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr addrspace(200) [[TMP0]], i64 0
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// VERY-AGGRESSIVE-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAY_PARAM_ADDR]], align 16
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP2]])
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test_unsized_array(int array_param[]) {
  do_stuff_untyped(&array_param[0]);
  // aggressive-or-less-remark@-1{{not setting bounds for pointer to 'int' (should set bounds on full array but size is not known)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for pointer to 'int' to 4 bytes}}
  // common-remark@-3{{not setting bounds for array subscript on 'int *' (array subscript on non-array type)}}

  // DBG-SUBOBJECT-SAFE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> should set bounds on full array but size is not known -> not setting bounds
  // DBG-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> should set bounds on full array but size is not known -> not setting bounds
  // DBG-NEXT: subscript 'int * __capability' subobj bounds check: array subscript on non-array type -> not setting bounds
  // DBG-VERY-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found scalar type -> setting bounds for 'int' address to 4
  do_stuff_untyped(array_param);
}

extern int bhnd_sprom_layouts[];

// AGGRESSIVE-OR-LESS-LABEL: @test_unsized_global_array(
// AGGRESSIVE-OR-LESS-NEXT:  entry:
// AGGRESSIVE-OR-LESS-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) @bhnd_sprom_layouts)
// AGGRESSIVE-OR-LESS-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) @bhnd_sprom_layouts)
// AGGRESSIVE-OR-LESS-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) @bhnd_sprom_layouts, i64 [[REMAINING_BYTES]])
// AGGRESSIVE-OR-LESS-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [0 x i32], ptr addrspace(200) [[TMP0]], i64 0, i64 0
// AGGRESSIVE-OR-LESS-NEXT:    [[CUR_OFFSET1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[ARRAYIDX]])
// AGGRESSIVE-OR-LESS-NEXT:    [[CUR_LEN2:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[ARRAYIDX]])
// AGGRESSIVE-OR-LESS-NEXT:    [[REMAINING_BYTES3:%.*]] = sub i64 [[CUR_LEN2]], [[CUR_OFFSET1]]
// AGGRESSIVE-OR-LESS-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 [[REMAINING_BYTES3]])
// AGGRESSIVE-OR-LESS-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// AGGRESSIVE-OR-LESS-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: @test_unsized_global_array(
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) @bhnd_sprom_layouts)
// VERY-AGGRESSIVE-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) @bhnd_sprom_layouts)
// VERY-AGGRESSIVE-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) @bhnd_sprom_layouts, i64 [[REMAINING_BYTES]])
// VERY-AGGRESSIVE-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [0 x i32], ptr addrspace(200) [[TMP0]], i64 0, i64 0
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[ARRAYIDX]], i64 4)
// VERY-AGGRESSIVE-NEXT:    call void @do_stuff_untyped(ptr addrspace(200) noundef [[TMP1]])
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test_unsized_global_array(void) {
  do_stuff_untyped(&bhnd_sprom_layouts[0]);
  // aggressive-or-less-remark@-1{{setting sub-object bounds for pointer to 'int' to remaining bytes (bounds on full array but size not known)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for pointer to 'int' to 4 bytes}}
  // common-remark@-3{{setting bounds for array subscript on 'int[]' to remaining bytes (array subscript on variable size type)}}

  // DBG-NEXT: subscript 'int[]' subobj bounds check: array subscript on variable size type -> setting bounds for 'int[]' subscript to remaining
  // DBG-VERY-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> bounds-mode is very-aggressive -> bounds on array[CONST] are fine -> Found scalar type -> setting bounds for 'int' address to 4
  // DBG-SUBOBJECT-SAFE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> bounds on full array but size not known -> setting bounds for 'int' address to remaining
  // DBG-AGGRESSIVE-NEXT: address 'int' subobj bounds check: Found array subscript -> index is a constant -> bounds on full array but size not known -> setting bounds for 'int' address to remaining
}

#ifdef NOTYET
// FIXME: should handle this case correctly:
void test_multidim_array(struct with_2d_array* s, int index) {
  int array2d[3][4];
  do_stuff(&(array2d)[0][0]));
  do_stuff(&(array2d)[index][index]));
}
#endif

// DBG-NEXT: ===-------------------------------------------------------------------------===
// DBG-NEXT: ... Statistics Collected ...
// DBG-NOT: cheri-bounds
// DBG: 10 cheri-bounds     - Number of & operators checked for tightening bounds
// DBG-NOT: cheri-bounds
// DBG: 9 cheri-bounds     - Number of [] operators checked for tightening bounds
// DBG-NOT: cheri-bounds
// DBG-AGGRESSIVE-NEXT:      4 cheri-bounds     - Number of & operators where container bounds were used
// DBG-SUBOBJECT-SAFE-NEXT:  6 cheri-bounds     - Number of & operators where container bounds were used
// DBG-SUBOBJECT-SAFE-NEXT:  1 cheri-bounds     - Number of & operators where remaining allocation size was used
// DBG-AGGRESSIVE-NEXT:      1 cheri-bounds     - Number of & operators where remaining allocation size was used
// DBG-NEXT:                 1 cheri-bounds     - Number of [] operators where remaining allocation size was used
// DBG-VERY-AGGRESSIVE-NEXT:10 cheri-bounds     - Number of & operators where bounds were tightened
// DBG-SUBOBJECT-SAFE-NEXT:  1 cheri-bounds     - Number of & operators where bounds were tightened
// DBG-AGGRESSIVE-NEXT:      3 cheri-bounds     - Number of & operators where bounds were tightened
// DBG-NEXT:                 6 cheri-bounds - Number of [] operators where bounds were tightened
// DBG-NOT: cheri-bounds
